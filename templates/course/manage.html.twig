{% extends 'base.html.twig' %}

{% block title %}G√©rer les Parcours - e-CO{% endblock %}

{% block stylesheets %}
    {{ parent() }}
    <link rel="stylesheet" href="{{ asset('assets/css/style.css') }}">
{% endblock %}

{% block body %}
<div class="parcours-page">
    <div class="parcours-header">
        <h1>Parcours</h1>
        <div class="parcours-header-actions">
            <div class="search-box">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="11" cy="11" r="8" stroke="#666" stroke-width="2"/>
                    <path d="M21 21l-4.35-4.35" stroke="#666" stroke-width="2" stroke-linecap="round"/>
                </svg>
                <input type="text" placeholder="Rechercher..." id="searchInput">
                <span class="status-badge">Mathis Bongo</span>
            </div>
            <button class="btn btn-primary" onclick="window.location.href='{{ path('app_course_create') }}'">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="12" cy="12" r="10" stroke="white" stroke-width="2"/>
                    <path d="M12 8v8M8 12h8" stroke="white" stroke-width="2" stroke-linecap="round"/>
                </svg>
                Nouveau Parcours
            </button>
        </div>
    </div>

    <div class="course-grid" id="courseList">
        <p style="text-align: center; color: #666; grid-column: 1 / -1;">Chargement des parcours...</p>
    </div>
</div>

<!-- Edit Course Modal -->
<div id="editCourseModal" class="modal">
    <div class="modal-content modal-large">
        <span class="close" onclick="closeEditModal()">&times;</span>
        <h2 id="modalTitle">Modifier le Parcours</h2>
        
        <div id="editCourseContent">
            <!-- Content loaded dynamically -->
        </div>
    </div>
</div>

<!-- QR Codes Modal -->
<div id="qrCodesModal" class="modal">
    <div class="modal-content modal-large">
        <span class="close" onclick="closeQRModal()">&times;</span>
        <h2>üî≤ QR Codes du Parcours</h2>
        
        <!-- Important information about QR code stability -->
        <div style="background: #e7f3ff; border-left: 4px solid #2196F3; padding: 1rem; margin-bottom: 1rem; border-radius: 4px;">
            <p style="margin: 0; color: #0c5460; font-weight: 600;">
                ‚ÑπÔ∏è <strong>Important :</strong> Ces QR codes sont <strong>permanents et ne changent jamais</strong> pour ce parcours.
            </p>
            <p style="margin: 0.5rem 0 0 0; color: #0c5460; font-size: 0.9rem;">
                Vous pouvez les imprimer et les placer sur le terrain en toute s√©curit√©. Ils resteront valides m√™me si vous consultez cette page plusieurs fois.
            </p>
        </div>
        
        <div style="text-align: right; margin-bottom: 1rem;">
            <button class="btn btn-primary" onclick="downloadAllQRCodes()">üì• T√©l√©charger tout (PDF)</button>
        </div>
        <div id="qrCodesContent" class="qr-codes-grid">
            <!-- QR codes loaded dynamically -->
        </div>
    </div>
</div>

{% block javascripts %}
    {{ parent() }}
    
    <script>
        // Use window object to prevent redeclaration errors with Turbo
        if (!window.manageCoursePageInitialized) {
            window.manageCoursePageInitialized = true;
            window.manageCourses = [];
            window.currentEditingCourse = null;
            window.editBoundaryMap = null;
            window.qrCodeLibraryLoaded = false;
            window.jspdfLibraryLoaded = false;
        }

        // Load Google Maps dynamically (same pattern as create.html.twig)
        window.loadGoogleMapsForManage = function() {
            if (window.google && window.google.maps) {
                console.log('Google Maps already loaded for manage page');
                return Promise.resolve();
            }

            if (document.querySelector('script[src*="maps.googleapis.com"]')) {
                console.log('Google Maps script already in document');
                return new Promise((resolve) => {
                    const checkGoogleMaps = setInterval(() => {
                        if (window.google && window.google.maps) {
                            clearInterval(checkGoogleMaps);
                            resolve();
                        }
                    }, 100);
                });
            }

            console.log('Loading Google Maps API for manage page...');
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://maps.googleapis.com/maps/api/js?key=AIzaSyBi8sXKGGafzB837kvxraWuqohlZ-JJRu8&libraries=geometry,places';
                script.async = true;
                script.defer = true;
                script.onload = function() {
                    console.log('Google Maps script loaded for manage page');
                    resolve();
                };
                script.onerror = function() {
                    console.error('Failed to load Google Maps script');
                    reject(new Error('Failed to load Google Maps'));
                };
                document.head.appendChild(script);
            });
        }

        // Cleanup function for Turbo navigation
        document.addEventListener('turbo:before-visit', function() {
            if (window.editBoundaryMap) {
                window.editBoundaryMap = null;
            }
        });

        // Load courses immediately
        async function initManagePage() {
            await loadCourses();
        }

        document.addEventListener('DOMContentLoaded', initManagePage);
        document.addEventListener('turbo:load', initManagePage);

        async function loadCourses() {
            try {
                const response = await fetch(`/api/sessions?t=${Date.now()}`);
                const data = await response.json();
                window.manageCourses = data.courses || [];
                displayCourses();
            } catch (error) {
                console.error('Error loading courses:', error);
                document.getElementById('courseList').innerHTML = '<p style="color: #d32f2f; text-align: center;">Erreur de chargement des parcours</p>';
            }
        }

        function displayCourses() {
            const container = document.getElementById('courseList');
            
            if (window.manageCourses.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666;">Aucun parcours disponible. <a href="{{ path('app_course_create') }}">Cr√©er un parcours</a></p>';
                return;
            }

            container.innerHTML = window.manageCourses.map((course, index) => {
                const waypointCount = course.waypoints ? course.waypoints.length : 0;
                const boundaries = course.boundaryPoints || course.boundary_points || [];
                const hasBoundaries = boundaries.length >= 3;
                
                let statusText, statusColor;
                if (course.status === 'finished') {
                    statusText = 'Termin√©';
                    statusColor = '#4caf50';
                } else {
                    statusText = 'En cours de cr√©ation';
                    statusColor = '#ff6b35';
                }
                
                return `
                    <div class="parcours-card">
                        <div class="parcours-card-header">
                            <div class="parcours-icon">S</div>
                            <div class="parcours-title">
                                <h3>${course.name || 'La Bastide'}</h3>
                                <span class="status-text" style="color: ${statusColor};">${statusText}</span>
                            </div>
                        </div>
                        
                        <p class="parcours-description">${course.description || 'D√©part √† l\'entr√©e sud sur la table'}</p>
                        
                        <div class="parcours-meta">
                            <span>
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M12 2L2 7v10c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V7l-10-5z" stroke="#1976d2" stroke-width="2" fill="none"/>
                                </svg>
                                ${waypointCount} balises
                            </span>
                            <span>
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <rect x="3" y="4" width="18" height="18" rx="2" stroke="#1976d2" stroke-width="2" fill="none"/>
                                    <line x1="3" y1="10" x2="21" y2="10" stroke="#1976d2" stroke-width="2"/>
                                    <line x1="8" y1="2" x2="8" y2="6" stroke="#1976d2" stroke-width="2"/>
                                    <line x1="16" y1="2" x2="16" y2="6" stroke="#1976d2" stroke-width="2"/>
                                </svg>
                                ${new Date(course.createdAt).toLocaleDateString('fr-FR')}
                            </span>
                        </div>
                        
                        <div class="parcours-actions">
                            <button class="action-btn btn-qr" onclick="viewQRCodes(${index})">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <rect x="3" y="3" width="7" height="7" stroke="white" stroke-width="2" fill="none"/>
                                    <rect x="14" y="3" width="7" height="7" stroke="white" stroke-width="2" fill="none"/>
                                    <rect x="3" y="14" width="7" height="7" stroke="white" stroke-width="2" fill="none"/>
                                    <rect x="14" y="14" width="7" height="7" stroke="white" stroke-width="2" fill="none"/>
                                </svg>
                                Qr Codes
                            </button>
                            ${course.status !== 'finished' ? `
                            <button class="action-btn btn-edit" onclick="editCourse(${index})">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" stroke="white" stroke-width="2" stroke-linecap="round"/>
                                    <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                                Modifier
                            </button>
                            <button class="action-btn btn-finish" onclick="finishCourse(${index})" style="background: #4caf50;">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M20 6L9 17l-5-5" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                </svg>
                                Terminer
                            </button>
                            <button class="action-btn btn-delete" onclick="deleteCourse(${index})">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" stroke="white" stroke-width="2" stroke-linecap="round"/>
                                </svg>
                            </button>
                            ` : `
                            <button class="action-btn btn-edit" onclick="editCourse(${index})" style="background: #2196f3;">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7z" stroke="white" stroke-width="2"/>
                                    <circle cx="12" cy="12" r="3" stroke="white" stroke-width="2"/>
                                </svg>
                                Voir
                            </button>
                            <span style="padding: 0.5rem 1rem; background: #4caf50; color: white; border-radius: 4px; font-weight: 500;">
                                ‚úì Termin√©
                            </span>
                            `}
                        </div>
                    </div>
                `;
            }).join('');
        }

        function editCourse(index) {
            const course = window.manageCourses[index];
            window.currentEditingCourse = { ...course, index };
            showEditModal();
        }

        function showEditModal() {
            const modal = document.getElementById('editCourseModal');
            const content = document.getElementById('editCourseContent');
            
            const course = window.currentEditingCourse;
            const isFinished = course.status === 'finished';
            
            console.log('Course status:', course.status, 'isFinished:', isFinished);
            
            if (isFinished) {
                // Read-only view for finished courses
                content.innerHTML = `
                    <div style="background: #fff3cd; padding: 1rem; border-radius: 8px; margin-bottom: 1rem; border-left: 4px solid #ffc107;">
                        <strong>‚ÑπÔ∏è Parcours termin√©</strong> - Ce parcours est termin√© et ne peut plus √™tre modifi√©.
                    </div>
                    
                    <!-- Basic Info -->
                    <div class="edit-section">
                        <h3>üìã Informations G√©n√©rales</h3>
                        <div class="form-group">
                            <label>Nom du parcours:</label>
                            <input type="text" value="${course.name || ''}" disabled style="background: #f5f5f5; cursor: not-allowed;">
                        </div>
                        <div class="form-group">
                            <label>Description:</label>
                            <textarea disabled style="background: #f5f5f5; cursor: not-allowed;">${course.description || ''}</textarea>
                        </div>
                    </div>

                    <!-- Boundaries -->
                    <div class="edit-section">
                        <h3>üó∫Ô∏è Limites du Parcours</h3>
                        <p id="editBoundaryStatus" style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">
                            ${course.boundaryPoints && course.boundaryPoints.length >= 3 
                                ? `‚úÖ ${course.boundaryPoints.length} points de limite d√©finis` 
                                : '‚ö†Ô∏è Aucune limite d√©finie'}
                        </p>
                        <div class="boundary-mini-map" id="editBoundaryMap"></div>
                    </div>

                    <!-- Waypoints -->
                    <div class="edit-section">
                        <h3>üéØ Balises</h3>
                        <div id="editWaypointsList">
                            ${renderWaypointsListReadOnly(course)}
                        </div>
                    </div>

                    <div class="form-actions">
                        <button type="button" class="btn btn-secondary" onclick="closeEditModal()">Fermer</button>
                    </div>
                `;
            } else {
                // Editable view for non-finished courses
                content.innerHTML = `
                    <form id="editCourseForm" onsubmit="saveCourseChanges(event)">
                        <!-- Basic Info -->
                        <div class="edit-section">
                            <h3>üìã Informations G√©n√©rales</h3>
                            <div class="form-group">
                                <label>Nom du parcours:</label>
                                <input type="text" id="editCourseName" value="${course.name || ''}" required>
                            </div>
                            <div class="form-group">
                                <label>Description:</label>
                                <textarea id="editCourseDescription">${course.description || ''}</textarea>
                            </div>
                        </div>

                        <!-- Boundaries -->
                        <div class="edit-section">
                            <h3>üó∫Ô∏è Limites du Parcours</h3>
                            <p style="font-size: 0.9rem; color: #666; margin-bottom: 0.5rem;">
                                Cliquez sur "Ajouter un point" puis sur la carte pour d√©finir les limites.<br>
                                <strong>Glissez</strong> les points pour les d√©placer, <strong>clic droit</strong> pour supprimer.
                            </p>
                            <p id="editBoundaryStatus" style="font-size: 0.9rem; color: #666; margin-bottom: 1rem;">
                                ${course.boundaryPoints && course.boundaryPoints.length >= 3 
                                    ? `‚úÖ ${course.boundaryPoints.length} points de limite d√©finis` 
                                    : '‚ö†Ô∏è Aucune limite d√©finie'}
                            </p>
                            <div class="boundary-mini-map" id="editBoundaryMap"></div>
                            <div style="display: flex; gap: 0.5rem; margin-top: 1rem;">
                                <button type="button" class="btn btn-secondary btn-small" id="editAddBoundaryPoint" onclick="toggleEditAddPoint()">üìç Ajouter un point</button>
                                <button type="button" class="btn btn-danger btn-small" onclick="clearEditBoundaryPoints()">üóëÔ∏è Effacer tout</button>
                            </div>
                        </div>

                        <!-- Waypoints -->
                        <div class="edit-section">
                            <h3>üéØ Balises</h3>
                            <div id="editWaypointsList">
                                ${renderWaypointsList(course)}
                            </div>
                            <button type="button" class="btn btn-secondary btn-small" onclick="addWaypoint()">‚ûï Ajouter une balise</button>
                        </div>

                        <div class="form-actions">
                            <button type="button" class="btn btn-secondary" onclick="closeEditModal()">Annuler</button>
                            <button type="submit" class="btn btn-success">‚úÖ Enregistrer les modifications</button>
                        </div>
                    </form>
                `;
            }
            
            modal.style.display = 'block';
            
            // Initialize boundary map after modal is shown (read-only for finished courses)
            setTimeout(() => initEditBoundaryMap(isFinished), 500);
        }

        function renderWaypointsList(course) {
            if (!course.waypoints || course.waypoints.length === 0) {
                return '<p style="color: #666;">Aucune balise</p>';
            }
            
            return course.waypoints.map((wp, idx) => `
                <div class="waypoint-list-item" data-waypoint-index="${idx}">
                    <div>
                        <strong>Balise ${wp.id || idx + 1}:</strong> ${wp.name || 'Sans nom'}
                        <br>
                        <small style="color: #666;">${wp.lat != null ? `üìç ${wp.lat.toFixed(6)}, ${wp.lng.toFixed(6)}` : '‚ö†Ô∏è Pas de coordonn√©es'}</small>
                    </div>
                    <div>
                        <button type="button" class="btn btn-warning btn-small" onclick="editWaypoint(${idx})">‚úèÔ∏è</button>
                        <button type="button" class="btn btn-danger btn-small" onclick="removeWaypoint(${idx})">üóëÔ∏è</button>
                    </div>
                </div>
            `).join('');
        }

        function renderWaypointsListReadOnly(course) {
            if (!course.waypoints || course.waypoints.length === 0) {
                return '<p style="color: #666;">Aucune balise</p>';
            }
            
            return course.waypoints.map((wp, idx) => `
                <div class="waypoint-list-item" style="background: #f5f5f5;">
                    <div>
                        <strong>Balise ${wp.id || idx + 1}:</strong> ${wp.name || 'Sans nom'}
                        <br>
                        <small style="color: #666;">${wp.lat != null ? `üìç ${wp.lat.toFixed(6)}, ${wp.lng.toFixed(6)}` : '‚ö†Ô∏è Pas de coordonn√©es'}</small>
                    </div>
                </div>
            `).join('');
        }

        async function initEditBoundaryMap(readOnly = false) {
            const mapElement = document.getElementById('editBoundaryMap');
            if (!mapElement || window.editBoundaryMap) return;

            // Load Google Maps if not already loaded
            try {
                await window.loadGoogleMapsForManage();
            } catch (error) {
                console.error('Failed to load Google Maps:', error);
                mapElement.innerHTML = '<div style="padding: 20px; text-align: center; color: #d32f2f;"><strong>‚ö†Ô∏è Impossible de charger Google Maps</strong><br><br>V√©rifiez votre connexion internet.</div>';
                return;
            }

            const course = window.currentEditingCourse;
            const center = course.boundaryPoints && course.boundaryPoints.length > 0 
                ? { lat: course.boundaryPoints[0].lat, lng: course.boundaryPoints[0].lng }
                : { lat: 45.828, lng: 1.256 };

            window.editBoundaryMap = new google.maps.Map(mapElement, {
                center: center,
                zoom: 15,
                mapTypeId: 'hybrid',
                tilt: 0,
                rotateControl: false,
                gestureHandling: readOnly ? 'cooperative' : 'auto',
                styles: [
                    { featureType: "poi", stylers: [{ visibility: "off" }] }
                ]
            });

            // Initialize boundary management (check both property names)
            window.editBoundaryPoints = course.boundaryPoints ? [...course.boundaryPoints] : 
                                        course.boundary_points ? [...course.boundary_points] : [];
            window.editBoundaryMarkers = [];
            window.editBoundaryPolygon = null;
            window.isEditAddingPoint = false;
            window.isReadOnlyMap = readOnly;
            console.log('Initialized editBoundaryPoints with', window.editBoundaryPoints.length, 'points');

            // Add click listener for adding points (only if not read-only)
            if (!readOnly) {
                window.editBoundaryMap.addListener('click', function(event) {
                    if (window.isEditAddingPoint) {
                        addEditBoundaryPoint(event.latLng.lat(), event.latLng.lng());
                        window.isEditAddingPoint = false;
                        updateEditAddButtonState();
                    }
                });
            }

            // Load existing boundaries
            const bounds = new google.maps.LatLngBounds();
            if (window.editBoundaryPoints.length > 0) {
                window.editBoundaryPoints.forEach((point, idx) => {
                    addEditBoundaryMarker(point.lat, point.lng, idx);
                    bounds.extend({ lat: point.lat, lng: point.lng });
                });
                updateEditBoundaryPolygon();
            }

            // Load existing beacons/waypoints
            if (course.waypoints && course.waypoints.length > 0) {
                course.waypoints.forEach((waypoint, idx) => {
                    if (waypoint.lat && waypoint.lng) {
                        const beaconMarker = new google.maps.Marker({
                            position: { 
                                lat: parseFloat(waypoint.lat), 
                                lng: parseFloat(waypoint.lng) 
                            },
                            map: window.editBoundaryMap,
                            title: waypoint.name || `Balise ${idx + 1}`,
                            icon: {
                                path: 'M 0,0 C -2,-20 -10,-22 -10,-30 A 10,10 0 1,1 10,-30 C 10,-22 2,-20 0,0 z',
                                fillColor: '#2196F3',
                                fillOpacity: 1,
                                strokeColor: '#ffffff',
                                strokeWeight: 2,
                                scale: 1,
                                anchor: new google.maps.Point(0, 0)
                            },
                            label: {
                                text: waypoint.name || `${idx + 1}`,
                                color: 'white',
                                fontSize: '10px',
                                fontWeight: 'bold'
                            }
                        });
                        bounds.extend({ lat: parseFloat(waypoint.lat), lng: parseFloat(waypoint.lng) });
                    }
                });
            }

            // Fit map to show all markers
            if (!bounds.isEmpty()) {
                window.editBoundaryMap.fitBounds(bounds);
            }
        }

        function addEditBoundaryMarker(lat, lng, index) {
            const isReadOnly = window.isReadOnlyMap || false;
            const marker = new google.maps.Marker({
                position: { lat: lat, lng: lng },
                map: window.editBoundaryMap,
                title: isReadOnly ? `Limite ${index + 1}` : `Limite ${index + 1} - Glisser pour d√©placer, clic droit pour supprimer`,
                draggable: !isReadOnly,
                label: {
                    text: `${index + 1}`,
                    color: 'white',
                    fontSize: '12px',
                    fontWeight: 'bold'
                },
                icon: {
                    path: google.maps.SymbolPath.CIRCLE,
                    scale: 8,
                    fillColor: isReadOnly ? '#9E9E9E' : '#FF6B35',
                    fillOpacity: 1,
                    strokeColor: '#ffffff',
                    strokeWeight: 2
                }
            });

            marker.boundaryPointIndex = index;

            // Drag event (only if not read-only)
            if (!isReadOnly) {
                marker.addListener('dragend', function(event) {
                    const newLat = event.latLng.lat();
                    const newLng = event.latLng.lng();
                    window.editBoundaryPoints[marker.boundaryPointIndex].lat = newLat;
                    window.editBoundaryPoints[marker.boundaryPointIndex].lng = newLng;
                    updateEditBoundaryPolygon();
                    // Update course object (both property names for compatibility)
                    window.currentEditingCourse.boundaryPoints = [...window.editBoundaryPoints];
                    window.currentEditingCourse.boundary_points = [...window.editBoundaryPoints];
                });

                // Right-click to remove
                marker.addListener('rightclick', function() {
                    if (confirm(`Supprimer le point de limite ${index + 1} ?`)) {
                        removeEditBoundaryPoint(marker.boundaryPointIndex);
                    }
                });
            }

            window.editBoundaryMarkers[index] = marker;
        }

        function addEditBoundaryPoint(lat, lng) {
            const index = window.editBoundaryPoints.length;
            window.editBoundaryPoints.push({ lat: lat, lng: lng });
            addEditBoundaryMarker(lat, lng, index);
            updateEditBoundaryPolygon();
            
            // Update course object
            window.currentEditingCourse.boundaryPoints = [...window.editBoundaryPoints];
            window.currentEditingCourse.boundary_points = [...window.editBoundaryPoints];
        }

        function removeEditBoundaryPoint(index) {
            // Remove marker
            if (window.editBoundaryMarkers[index]) {
                window.editBoundaryMarkers[index].setMap(null);
            }

            // Remove from arrays
            window.editBoundaryPoints.splice(index, 1);
            window.editBoundaryMarkers.splice(index, 1);

            // Re-index remaining markers
            window.editBoundaryMarkers.forEach((marker, idx) => {
                marker.boundaryPointIndex = idx;
                marker.setLabel({
                    text: `${idx + 1}`,
                    color: 'white',
                    fontSize: '12px',
                    fontWeight: 'bold'
                });
                marker.setTitle(`Limite ${idx + 1} - Glisser pour d√©placer, clic droit pour supprimer`);
            });

            updateEditBoundaryPolygon();
            
            // Update course object
            window.currentEditingCourse.boundaryPoints = [...window.editBoundaryPoints];
        }

        function updateEditBoundaryPolygon() {
            // Remove old polygon
            if (window.editBoundaryPolygon) {
                window.editBoundaryPolygon.setMap(null);
            }

            // Create new polygon if we have at least 3 points
            if (window.editBoundaryPoints.length >= 3) {
                const path = window.editBoundaryPoints.map(p => ({ lat: p.lat, lng: p.lng }));
                window.editBoundaryPolygon = new google.maps.Polygon({
                    paths: path,
                    strokeColor: '#667eea',
                    strokeOpacity: 0.8,
                    strokeWeight: 2,
                    fillColor: '#667eea',
                    fillOpacity: 0.2,
                    map: window.editBoundaryMap
                });
            }
            
            // Update status text
            updateEditBoundaryStatus();
        }

        function updateEditBoundaryStatus() {
            const statusElement = document.getElementById('editBoundaryStatus');
            if (!statusElement) return;
            
            const count = window.editBoundaryPoints ? window.editBoundaryPoints.length : 0;
            if (count >= 3) {
                statusElement.innerHTML = `‚úÖ ${count} points de limite d√©finis`;
                statusElement.style.color = '#2e7d32';
            } else if (count > 0) {
                statusElement.innerHTML = `‚ö†Ô∏è ${count} point(s) d√©fini(s) - minimum 3 requis`;
                statusElement.style.color = '#f57c00';
            } else {
                statusElement.innerHTML = '‚ö†Ô∏è Aucune limite d√©finie';
                statusElement.style.color = '#666';
            }
        }

        function toggleEditAddPoint() {
            window.isEditAddingPoint = !window.isEditAddingPoint;
            updateEditAddButtonState();
        }

        function updateEditAddButtonState() {
            const btn = document.getElementById('editAddBoundaryPoint');
            if (!btn) return;
            
            if (window.isEditAddingPoint) {
                btn.classList.add('active');
                btn.textContent = 'üìç Cliquez sur la carte...';
                btn.style.backgroundColor = '#4CAF50';
            } else {
                btn.classList.remove('active');
                btn.textContent = 'üìç Ajouter un point';
                btn.style.backgroundColor = '';
            }
        }

        function clearEditBoundaryPoints() {
            if (!confirm('Supprimer tous les points de limite ?')) return;
            
            window.editBoundaryMarkers.forEach(marker => marker.setMap(null));
            window.editBoundaryMarkers = [];
            window.editBoundaryPoints = [];
            
            if (window.editBoundaryPolygon) {
                window.editBoundaryPolygon.setMap(null);
                window.editBoundaryPolygon = null;
            }
            
            // Update course object
            window.currentEditingCourse.boundaryPoints = [];
        }

        function addWaypoint() {
            const course = window.currentEditingCourse;
            
            // Generate unique ID for new waypoint (find highest ID + 1)
            let maxId = 0;
            if (course.waypoints && course.waypoints.length > 0) {
                maxId = Math.max(...course.waypoints.map(wp => wp.id || 0));
            }
            const newId = maxId + 1;
            
            // Create new waypoint with unique ID
            const newWaypoint = {
                id: newId,  // PERMANENT unique ID - never changes!
                name: `Nouvelle balise ${newId}`,
                description: '',
                lat: null,
                lng: null,
                type: 'control'
            };
            
            // Add to waypoints array
            if (!course.waypoints) {
                course.waypoints = [];
            }
            course.waypoints.push(newWaypoint);
            
            // Refresh the waypoints list
            document.getElementById('editWaypointsList').innerHTML = renderWaypointsList(course);
            
            // Show important warning
            alert('‚ö†Ô∏è IMPORTANT: Nouvelle balise ajout√©e!\n\n' +
                  'Cette balise a un nouveau QR code qui n\'existait pas avant.\n' +
                  'Vous devez:\n' +
                  '1. Consulter les QR codes mis √† jour\n' +
                  '2. Imprimer UNIQUEMENT le nouveau QR code (Balise ' + newId + ')\n' +
                  '3. Placer ce nouveau QR code sur le terrain\n\n' +
                  'Les autres QR codes restent inchang√©s!');
        }

        function editWaypoint(index) {
            alert(`Modifier balise ${index + 1}`);
        }

        function removeWaypoint(index) {
            if (confirm(`Supprimer la balise ${index + 1} ?`)) {
                window.currentEditingCourse.waypoints.splice(index, 1);
                document.getElementById('editWaypointsList').innerHTML = renderWaypointsList(window.currentEditingCourse);
            }
        }

        function clearBoundaries() {
            if (confirm('Effacer toutes les limites du parcours ?')) {
                window.currentEditingCourse.boundaryPoints = null;
                if (window.editBoundaryMap) {
                    // Reinitialize map
                    window.editBoundaryMap = null;
                    initEditBoundaryMap();
                }
            }
        }

        async function saveCourseChanges(event) {
            event.preventDefault();
            
            // Update course data from form
            const course = window.currentEditingCourse;
            course.name = document.getElementById('editCourseName').value;
            course.description = document.getElementById('editCourseDescription').value;
            
            // Prepare data for API (use boundaryPoints and boundary_points for compatibility)
            const boundaryData = window.editBoundaryPoints || course.boundaryPoints || course.boundary_points || [];
            console.log('Saving boundaries:', boundaryData);
            console.log('window.editBoundaryPoints:', window.editBoundaryPoints);
            console.log('course.boundaryPoints:', course.boundaryPoints);
            console.log('course.boundary_points:', course.boundary_points);
            const updateData = {
                name: course.name,
                description: course.description,
                boundaryPoints: boundaryData,
                waypoints: (course.waypoints || []).map(wp => ({
                    name: wp.name,
                    latitude: wp.latitude || wp.lat || 0,
                    longitude: wp.longitude || wp.lng || 0,
                    type: wp.type || 'control',
                    qr: wp.qr || ''
                })).filter(wp => wp.latitude !== 0 && wp.longitude !== 0) // Only include waypoints with valid coordinates
            };
            
            try {
                const response = await fetch(`/api/course/${course.id}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(updateData)
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    // Update the course in the local array with the saved boundary data
                    const courseIndex = course.index !== undefined ? course.index : window.manageCourses.findIndex(c => c.id === course.id);
                    if (courseIndex !== -1) {
                        window.manageCourses[courseIndex].boundaryPoints = boundaryData;
                        window.manageCourses[courseIndex].boundary_points = boundaryData;
                        window.manageCourses[courseIndex].name = course.name;
                        window.manageCourses[courseIndex].description = course.description;
                    }
                    
                    alert('‚úÖ Modifications enregistr√©es avec succ√®s !');
                    closeEditModal();
                    await loadCourses(); // Reload courses from database to ensure sync
                } else {
                    throw new Error(result.error || 'Erreur lors de la sauvegarde');
                }
            } catch (error) {
                console.error('Error saving course:', error);
                alert('‚ùå Erreur lors de la sauvegarde : ' + error.message);
            }
        }

        function closeEditModal() {
            document.getElementById('editCourseModal').style.display = 'none';
            window.editBoundaryMap = null;
            window.currentEditingCourse = null;
        }

        async function viewQRCodes(index) {
            const course = window.manageCourses[index];
            const modal = document.getElementById('qrCodesModal');
            const content = document.getElementById('qrCodesContent');
            
            // Check if course has been modified (compare waypoint count)
            const waypointCount = course.waypoints ? course.waypoints.length : 0;
            const previousWaypointCount = course.initialWaypointCount || waypointCount;
            
            if (waypointCount !== previousWaypointCount) {
                const diff = waypointCount - previousWaypointCount;
                const message = diff > 0 
                    ? `‚ö†Ô∏è ATTENTION: ${diff} balise(s) ont √©t√© ajout√©es depuis la cr√©ation.\n\nVous verrez de NOUVEAUX QR codes pour ces balises.\nLes QR codes existants restent inchang√©s.`
                    : `‚ö†Ô∏è ATTENTION: ${Math.abs(diff)} balise(s) ont √©t√© supprim√©es.\n\nCertains QR codes ne sont plus pr√©sents dans la liste.\nNe les r√©imprimez pas!`;
                
                alert(message);
            }
            
            content.innerHTML = '<p style="text-align: center;">G√©n√©ration des QR codes...</p>';
            modal.style.display = 'block';
            
            setTimeout(() => generateQRCodes(course), 100);
        }

        function generateQRCodes(course, retryCount = 0) {
            // Check if QRCode library is loaded
            if (typeof QRCode === 'undefined') {
                if (retryCount > 50) {
                    document.getElementById('qrCodesContent').innerHTML = '<p style="color: #d32f2f; text-align: center;">Erreur: Impossible de charger la biblioth√®que QR Code. Veuillez recharger la page.</p>';
                    return;
                }
                console.log('QRCode library not loaded yet, retrying... (' + retryCount + ')');
                setTimeout(() => generateQRCodes(course, retryCount + 1), 300);
                return;
            }
            
            console.log('QRCode library loaded! Generating codes...');
            const content = document.getElementById('qrCodesContent');
            const qrCodes = [];

            // IMPORTANT: Use course creation timestamp (fixed) instead of current time
            // This ensures QR codes are STABLE and don't change when viewed multiple times
            const courseTimestamp = course.created_at || course.id;

            // Start Point - START QR Code
            const startQRData = {
                type: 'START_COURSE',
                courseId: course.id,
                courseName: course.name,
                pointName: course.startPoint?.name || 'Depart',
                courseCreated: courseTimestamp  // FIXED timestamp from course creation
            };
            qrCodes.push({
                label: `DEPART - DEBUT DU PARCOURS`,
                displayLabel: `Depart - DEBUT`,
                data: JSON.stringify(startQRData),
                color: '#000000'
            });

            // Waypoints QR Codes
            // IMPORTANT: QR codes are sorted by waypoint ID (not sequence) for stability
            // This means deleting/adding waypoints doesn't change existing QR codes
            if (course.waypoints) {
                // Sort by ID to ensure consistent order
                const sortedWaypoints = [...course.waypoints].sort((a, b) => a.id - b.id);
                
                sortedWaypoints.forEach((wp) => {
                    const wpQRData = {
                        type: 'WAYPOINT',
                        courseId: course.id,
                        courseName: course.name,
                        waypointId: wp.id,  // STABLE unique ID - never changes!
                        waypointName: wp.name,
                        courseCreated: courseTimestamp  // FIXED timestamp
                        // NOTE: No 'sequence' field! Order doesn't matter for QR codes.
                        // Students scan in any order they want during the course.
                    };
                    qrCodes.push({
                        label: wp.name,
                        displayLabel: wp.name,
                        data: JSON.stringify(wpQRData),
                        color: '#000000'
                    });
                });
            }

            // Start Point - END QR Code
            const endQRData = {
                type: 'END_COURSE',
                courseId: course.id,
                courseName: course.name,
                pointName: course.startPoint?.name || 'Arrivee',
                courseCreated: courseTimestamp  // FIXED timestamp
            };
            qrCodes.push({
                label: `ARRIVEE - FIN DU PARCOURS`,
                displayLabel: `Arrivee - FIN`,
                data: JSON.stringify(endQRData),
                color: '#000000'
            });

            // Generate QR codes
            content.innerHTML = qrCodes.map((qr, idx) => `
                <div class="qr-code-item">
                    <h4 style="color: #000000">${qr.displayLabel || qr.label}</h4>
                    <div id="qr-container-${idx}" style="display: flex; justify-content: center;"></div>
                </div>
            `).join('');

            // Render QR codes using QRCode constructor (qrcodejs library)
            qrCodes.forEach((qr, idx) => {
                const container = document.getElementById(`qr-container-${idx}`);
                new QRCode(container, {
                    text: qr.data,
                    width: 180,
                    height: 180,
                    colorDark: '#000000',
                    colorLight: '#ffffff',
                    correctLevel: QRCode.CorrectLevel.H
                });
            });

            window.currentCourseQRCodes = { course, qrCodes };
        }

        function downloadAllQRCodes() {
            if (!window.currentCourseQRCodes) return;
            
            // Check if jsPDF library is loaded
            if (typeof window.jspdf === 'undefined') {
                alert('Le g√©n√©rateur PDF se charge... Veuillez r√©essayer dans un instant.');
                return;
            }

            const { course, qrCodes } = window.currentCourseQRCodes;
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF('portrait', 'mm', 'a4');

            qrCodes.forEach((qr, idx) => {
                // Add new page for each QR code (except first)
                if (idx > 0) {
                    pdf.addPage();
                }

                // QRCode library creates an img inside the container
                const container = document.getElementById(`qr-container-${idx}`);
                const img = container ? container.querySelector('img') : null;
                
                if (img) {
                    // Page title at top
                    pdf.setFontSize(24);
                    pdf.setTextColor(0, 0, 0);
                    const titleText = `Parcours: ${course.name}`;
                    const titleWidth = pdf.getTextWidth(titleText);
                    pdf.text(titleText, (210 - titleWidth) / 2, 20);
                    
                    // Large QR code centered on page (150x150mm)
                    const qrSize = 150;
                    const qrX = (210 - qrSize) / 2; // Center horizontally (A4 width = 210mm)
                    const qrY = 60; // Below the title
                    pdf.addImage(img.src, 'PNG', qrX, qrY, qrSize, qrSize);
                    
                    // QR code label at bottom (easy to cut off)
                    pdf.setFontSize(18);
                    pdf.setTextColor(0, 0, 0);
                    const labelWidth = pdf.getTextWidth(qr.label);
                    pdf.text(qr.label, (210 - labelWidth) / 2, 270);
                }
            });

            pdf.save(`QR_Codes_${course.name.replace(/[^a-z0-9]/gi, '_')}.pdf`);
        }

        function closeQRModal() {
            document.getElementById('qrCodesModal').style.display = 'none';
        }

        async function finishCourse(index) {
            const course = window.manageCourses[index];
            if (!confirm(`Marquer le parcours "${course.name}" comme termin√© ?\n\nUne fois termin√©, le parcours ne pourra plus √™tre modifi√©.\n\nContinuer ?`)) {
                return;
            }
            
            try {
                const response = await fetch(`/api/parcours/${course.id}/finish`, {
                    method: 'POST'
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    alert('‚úÖ Parcours marqu√© comme termin√© !');
                    await loadCourses();
                } else {
                    throw new Error(result.error || 'Erreur lors de la finalisation');
                }
            } catch (error) {
                console.error('Error finishing course:', error);
                alert('‚ùå Erreur : ' + error.message);
            }
        }

        async function deleteCourse(index) {
            const course = window.manageCourses[index];
            if (!confirm(`Supprimer le parcours "${course.name}" ?\n\nCette action est irr√©versible et supprimera:\n- Le parcours\n- Toutes les balises\n- Toutes les limites\n\nContinuer ?`)) {
                return;
            }
            
            try {
                const response = await fetch(`/api/course/${course.id}`, {
                    method: 'DELETE'
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    alert('‚úÖ Parcours supprim√© avec succ√®s !');
                    await loadCourses(); // Reload courses from database
                } else {
                    throw new Error(result.error || 'Erreur lors de la suppression');
                }
            } catch (error) {
                console.error('Error deleting course:', error);
                alert('‚ùå Erreur lors de la suppression : ' + error.message);
            }
        }

        // Close modals on outside click
        window.onclick = function(event) {
            const editModal = document.getElementById('editCourseModal');
            const qrModal = document.getElementById('qrCodesModal');
            if (event.target === editModal) {
                closeEditModal();
            }
            if (event.target === qrModal) {
                closeQRModal();
            }
        };
    </script>
    
    <!-- Load libraries from local assets (no CDN needed) -->
    <script src="{{ asset('assets/js/qrcode.min.js') }}" onload="window.qrCodeLibraryLoaded = true; console.log('QRCode library loaded from local assets');"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" data-turbo-track="reload" async onload="window.jspdfLibraryLoaded = true; console.log('jsPDF library loaded');"></script>
{% endblock %}
{% endblock %}
