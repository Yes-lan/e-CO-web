{% extends 'base.html.twig' %}

{% block title %}{{ 'parcours.create_page_title'|trans }}{% endblock %}

{% block stylesheets %}
    {{ parent() }}
    <link rel="stylesheet" href="{{ asset('assets/css/style.css') }}">
{% endblock %}

{% block body %}
    <div class="course-creation-container">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
            <a href="{{ path('app_parcours_list') }}" class="back-link">‚Üê Retour √† la liste</a>
            <a href="{{ path('app_parcours_list') }}" class="btn btn-info btn-small">üóÇÔ∏è G√©rer les parcours</a>
        </div>

        <div class="creation-header">
            <h1>üìç Cr√©er un Nouveau Parcours</h1>
            <p>Configurez votre parcours d'orientation √©tape par √©tape</p>
        </div>

        <form id="courseCreationForm">
            <!-- Informations g√©n√©rales -->
            <div class="form-section">
                <h2>üìã Informations G√©n√©rales</h2>
                
                <div class="form-group">
                    <label for="courseName">Nom du parcours *</label>
                    <input type="text" id="courseName" name="courseName" required 
                           placeholder="Ex: Parcours For√™t de Montmorency">
                </div>

                <div class="form-group">
                    <label for="courseDescription">Description</label>
                    <textarea id="courseDescription" name="courseDescription" 
                              placeholder="D√©crivez votre parcours d'orientation..."></textarea>
                </div>
            </div>

            <!-- Point de d√©part/arriv√©e -->
            <div class="form-section">
                <h2>üö© Point de D√©part/Arriv√©e</h2>
                
                <div class="info-box">
                    <p>‚ÑπÔ∏è Le point de d√©part sera √©galement le point d'arriv√©e du parcours.</p>
                </div>

                <div class="form-group">
                    <label for="startPointName">Nom du point de d√©part *</label>
                    <input type="text" id="startPointName" name="startPointName" required 
                           placeholder="Ex: Parking de la for√™t">
                </div>

                <div class="form-group">
                    <label for="startPointDescription">Description du point de d√©part</label>
                    <textarea id="startPointDescription" name="startPointDescription" 
                              placeholder="Ex: Parking principal √† l'entr√©e sud de la for√™t"></textarea>
                </div>

                <div class="form-group">
                    <label>Position GPS</label>
                    <p style="color: #666; font-size: 0.9rem;">
                        üì± Les coordonn√©es GPS seront enregistr√©es lors du scan du QR code par l'enseignant sur le terrain.
                    </p>
                </div>
            </div>

            <!-- D√©finition des limites du parcours -->
            <div class="form-section">
                <h2>üó∫Ô∏è Limites du Parcours</h2>
                
                <div class="info-box">
                    <p><strong>üìñ Guide d'utilisation de la carte :</strong></p>
                    <ul style="margin: 0.5rem 0; padding-left: 1.5rem; font-size: 0.9rem;">
                        <li><strong>Ajouter un point :</strong> Cliquez sur "üìç Ajouter un point de limite", puis cliquez sur la carte √† l'endroit souhait√©</li>
                        <li><strong>D√©placer un point :</strong> Cliquez et glissez n'importe quel point pour le repositionner</li>
                        <li><strong>Supprimer un point :</strong> Faites un clic droit sur un point pour le supprimer</li>
                        <li><strong>Test rapide :</strong> Utilisez "üß™ Charger limites de test" pour charger des points d'exemple</li>
                        <li><strong>Coordonn√©es automatiques :</strong> Si vous d√©finissez des limites (3+ points), toutes les balises recevront automatiquement des coordonn√©es GPS al√©atoires dans cette zone lors de la cr√©ation !</li>
                    </ul>
                </div>

                <div class="boundary-map-container" style="margin-bottom: 1rem;">
                    <div id="boundaryMap" style="width: 100%; height: 400px; border: 2px solid #ddd; border-radius: 8px;"></div>
                </div>

                <div class="boundary-controls" style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
                    <button type="button" class="btn btn-info btn-small" id="addBoundaryPoint">
                        üìç Ajouter un point de limite
                    </button>
                    <button type="button" class="btn btn-warning btn-small" id="clearBoundaryPoints">
                        üóëÔ∏è Effacer les limites
                    </button>
                    <button type="button" class="btn btn-secondary btn-small" id="loadTestBoundary">
                        üß™ Charger limites de test
                    </button>
                </div>

                <div id="boundaryPointsList" style="margin-bottom: 1rem;">
                    <p style="color: #666; font-size: 0.9rem;">Aucun point de limite d√©fini</p>
                </div>
            </div>

            <!-- Nombre de balises -->
            <div class="form-section">
                <h2>üéØ Configuration des Balises</h2>
                
                <div class="form-group">
                    <label for="waypointCount">Nombre de balises (hors d√©part/arriv√©e)</label>
                    <div class="waypoint-count-selector">
                        <input type="number" id="waypointCount" name="waypointCount" 
                               min="1" max="20" value="5">
                        <button type="button" class="btn btn-secondary btn-small" id="generateWaypoints">
                            G√©n√©rer les balises
                        </button>
                    </div>
                </div>

                <div id="waypointsContainer" class="waypoints-container">
                    <!-- Waypoints will be generated here -->
                </div>
            </div>

            <!-- Actions -->
            <div class="form-actions">
                <button type="submit" class="btn btn-success">
                    ‚úÖ Cr√©er le parcours
                </button>
            </div>
        </form>
    </div>

    {% block javascripts %}
        {{ parent() }}
        
        <script>
            // Boundary map management - use window object to prevent redeclaration
            if (!window.boundaryMapInitialized) {
                window.boundaryMap = null;
                window.boundaryPoints = [];
                window.boundaryMarkers = [];
                window.boundaryPolygon = null;
                window.isAddingBoundaryPoint = false;
                window.boundaryMapInitialized = true;
                window.googleMapsAttempts = 0;
            }

            window.initBoundaryMap = function() {
                const mapElement = document.getElementById('boundaryMap');
                if (!mapElement) {
                    console.log('Map element not found');
                    return;
                }

                if (window.boundaryMap) {
                    console.log('Boundary map already initialized');
                    return;
                }

                if (!window.google || !window.google.maps) {
                    window.googleMapsAttempts++;
                    if (window.googleMapsAttempts > 50) {
                        console.error('Google Maps failed to load after 50 attempts (5 seconds)');
                        mapElement.innerHTML = '<div style="padding: 20px; text-align: center; color: #d32f2f;"><strong>‚ö†Ô∏è Erreur de chargement de Google Maps</strong><br><br>Veuillez:<br>1. D√©sactiver votre bloqueur de publicit√©s/extensions de confidentialit√© pour localhost<br>2. Recharger la page (F5)<br><br>Si le probl√®me persiste, v√©rifiez votre connexion internet.</div>';
                        return;
                    }
                    console.log('Waiting for Google Maps API... attempt', window.googleMapsAttempts);
                    setTimeout(window.initBoundaryMap, 100);
                    return;
                }

                try {
                    // Default center (can be changed)
                    const defaultCenter = { lat: 45.828, lng: 1.256 };

                    window.boundaryMap = new google.maps.Map(mapElement, {
                        center: defaultCenter,
                        zoom: 15,
                        mapTypeId: 'hybrid',
                        mapTypeControl: true,
                        streetViewControl: false,
                        fullscreenControl: true,
                        tilt: 0, // Disable 3D tilt
                        rotateControl: false, // Disable rotation
                        styles: [
                            {
                                featureType: "poi",
                                stylers: [{ visibility: "off" }]
                            },
                            {
                                featureType: "poi.business",
                                stylers: [{ visibility: "off" }]
                            },
                            {
                                featureType: "transit",
                                elementType: "labels.icon",
                                stylers: [{ visibility: "off" }]
                            }
                        ]
                    });

                    // Add click listener for adding points
                    window.boundaryMap.addListener('click', function(event) {
                        if (window.isAddingBoundaryPoint) {
                            window.addBoundaryPoint(event.latLng.lat(), event.latLng.lng());
                            window.isAddingBoundaryPoint = false;
                            window.updateAddButtonState();
                        }
                    });

                    console.log('Boundary map initialized successfully');
                } catch (error) {
                    console.error('Error initializing boundary map:', error);
                    mapElement.innerHTML = '<div style="padding: 20px; text-align: center; color: #d32f2f;"><strong>‚ö†Ô∏è Erreur lors de l\'initialisation de la carte</strong><br><br>' + error.message + '</div>';
                }
            }

            // Load Google Maps script dynamically
            window.loadGoogleMapsForBoundary = function() {
                if (window.google && window.google.maps) {
                    console.log('Google Maps already loaded');
                    window.initBoundaryMap();
                    return;
                }

                if (document.querySelector('script[src*="maps.googleapis.com"]')) {
                    console.log('Google Maps script already in document');
                    setTimeout(window.initBoundaryMap, 500);
                    return;
                }

                console.log('Loading Google Maps API...');
                const script = document.createElement('script');
                script.src = 'https://maps.googleapis.com/maps/api/js?key=AIzaSyBi8sXKGGafzB837kvxraWuqohlZ-JJRu8&libraries=geometry,places';
                script.async = true;
                script.defer = true;
                script.onload = function() {
                    console.log('Google Maps script loaded');
                    setTimeout(window.initBoundaryMap, 500);
                };
                script.onerror = function() {
                    console.error('Failed to load Google Maps script');
                    const mapElement = document.getElementById('boundaryMap');
                    if (mapElement) {
                        mapElement.innerHTML = '<div style="padding: 20px; text-align: center; color: #d32f2f;"><strong>‚ö†Ô∏è Impossible de charger Google Maps</strong><br><br>V√©rifiez votre connexion internet et d√©sactivez les bloqueurs de publicit√©s.</div>';
                    }
                };
                document.head.appendChild(script);
            }

            window.addBoundaryPoint = function(lat, lng) {
                const pointId = window.boundaryPoints.length + 1;
                const point = { id: pointId, lat: lat, lng: lng };
                window.boundaryPoints.push(point);

                // Create draggable marker
                const marker = new google.maps.Marker({
                    position: { lat: lat, lng: lng },
                    map: window.boundaryMap,
                    title: `Limite ${pointId} - Glisser pour d√©placer, clic droit pour supprimer`,
                    draggable: true, // Make marker draggable
                    label: {
                        text: `${pointId}`,
                        color: 'white',
                        fontSize: '12px',
                        fontWeight: 'bold'
                    },
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 8,
                        fillColor: '#FF6B35',
                        fillOpacity: 1,
                        strokeColor: '#ffffff',
                        strokeWeight: 2
                    }
                });

                // Store reference to point in marker
                marker.boundaryPointIndex = window.boundaryPoints.length - 1;

                // Add drag event to update position
                marker.addListener('dragend', function(event) {
                    const newLat = event.latLng.lat();
                    const newLng = event.latLng.lng();
                    const index = marker.boundaryPointIndex;
                    
                    // Update point coordinates
                    window.boundaryPoints[index].lat = newLat;
                    window.boundaryPoints[index].lng = newLng;
                    
                    // Update polygon and list
                    window.updateBoundaryPolygon();
                    window.updateBoundaryPointsList();
                    
                    console.log(`Point ${window.boundaryPoints[index].id} d√©plac√© vers ${newLat.toFixed(6)}, ${newLng.toFixed(6)}`);
                });

                // Add right-click event to remove point
                marker.addListener('rightclick', function() {
                    if (confirm(`Supprimer le point de limite ${point.id} ?`)) {
                        window.removeBoundaryPoint(marker.boundaryPointIndex);
                    }
                });

                window.boundaryMarkers.push(marker);
                window.updateBoundaryPolygon();
                window.updateBoundaryPointsList();
            }

            window.removeBoundaryPoint = function(index) {
                // Remove marker from map
                if (window.boundaryMarkers[index]) {
                    window.boundaryMarkers[index].setMap(null);
                }

                // Remove from arrays
                window.boundaryPoints.splice(index, 1);
                window.boundaryMarkers.splice(index, 1);

                // Re-index remaining markers and renumber points
                window.boundaryMarkers.forEach((marker, idx) => {
                    marker.boundaryPointIndex = idx;
                    window.boundaryPoints[idx].id = idx + 1;
                    marker.setLabel({
                        text: `${idx + 1}`,
                        color: 'white',
                        fontSize: '12px',
                        fontWeight: 'bold'
                    });
                    marker.setTitle(`Limite ${idx + 1} - Glisser pour d√©placer, clic droit pour supprimer`);
                });

                // Update polygon and list
                window.updateBoundaryPolygon();
                window.updateBoundaryPointsList();
            }

            window.updateBoundaryPolygon = function() {
                // Remove old polygon
                if (window.boundaryPolygon) {
                    window.boundaryPolygon.setMap(null);
                }

                // Create new polygon if we have at least 3 points
                if (window.boundaryPoints.length >= 3) {
                    const path = window.boundaryPoints.map(p => ({ lat: p.lat, lng: p.lng }));
                    
                    window.boundaryPolygon = new google.maps.Polygon({
                        paths: path,
                        strokeColor: '#667eea',
                        strokeOpacity: 0.8,
                        strokeWeight: 2,
                        fillColor: '#667eea',
                        fillOpacity: 0.2,
                        map: window.boundaryMap
                    });
                }
            }

            window.updateBoundaryPointsList = function() {
                const listElement = document.getElementById('boundaryPointsList');
                if (window.boundaryPoints.length === 0) {
                    listElement.innerHTML = '<p style="color: #666; font-size: 0.9rem;">Aucun point de limite d√©fini</p>';
                } else {
                    listElement.innerHTML = `
                        <p style="color: #666; font-size: 0.9rem; margin-bottom: 0.5rem;">
                            ${window.boundaryPoints.length} point(s) de limite d√©fini(s):
                        </p>
                        <div style="display: grid; gap: 0.3rem;">
                            ${window.boundaryPoints.map(p => `
                                <div style="font-size: 0.85rem; color: #555;">
                                    <strong>Point ${p.id}:</strong> ${p.lat.toFixed(6)}, ${p.lng.toFixed(6)}
                                </div>
                            `).join('')}
                        </div>
                    `;
                }
            }

            window.clearBoundaryPoints = function() {
                window.boundaryPoints = [];
                window.boundaryMarkers.forEach(marker => marker.setMap(null));
                window.boundaryMarkers = [];
                if (window.boundaryPolygon) {
                    window.boundaryPolygon.setMap(null);
                    window.boundaryPolygon = null;
                }
                window.updateBoundaryPointsList();
            }

            window.loadTestBoundaryPoints = function() {
                fetch('/assets/data/test-boundary-points.json')
                    .then(response => response.json())
                    .then(data => {
                        window.clearBoundaryPoints();
                        data.points.forEach(point => {
                            window.addBoundaryPoint(point.lat, point.lng);
                        });
                        
                        // Fit map to bounds
                        if (window.boundaryPoints.length > 0) {
                            const bounds = new google.maps.LatLngBounds();
                            window.boundaryPoints.forEach(p => {
                                bounds.extend({ lat: p.lat, lng: p.lng });
                            });
                            window.boundaryMap.fitBounds(bounds);
                        }
                    })
                    .catch(error => console.error('Error loading test boundary:', error));
            }

            window.updateAddButtonState = function() {
                const btn = document.getElementById('addBoundaryPoint');
                if (window.isAddingBoundaryPoint) {
                    btn.classList.add('active');
                    btn.textContent = 'üìç Cliquez sur la carte...';
                    btn.style.backgroundColor = '#4CAF50';
                } else {
                    btn.classList.remove('active');
                    btn.textContent = 'üìç Ajouter un point de limite';
                    btn.style.backgroundColor = '';
                }
            }

            // Initialize boundary map when DOM is ready
            document.addEventListener('DOMContentLoaded', function() {
                if (document.getElementById('boundaryMap')) {
                    window.loadGoogleMapsForBoundary();
                }
            });

            // Also try on turbo:load for Turbo compatibility
            document.addEventListener('turbo:load', function() {
                if (document.getElementById('boundaryMap')) {
                    window.loadGoogleMapsForBoundary();
                }
            });

            // Course creation form initialization
            (function() {
                // Notification helper function
                function showNotification(message, type = 'success') {
                    // Remove any existing notifications
                    const existingNotif = document.querySelector('.notification');
                    if (existingNotif) {
                        existingNotif.remove();
                    }

                    const notification = document.createElement('div');
                    notification.className = `notification ${type}`;
                    notification.textContent = message;
                    document.body.appendChild(notification);

                    setTimeout(() => {
                        notification.style.animation = 'slideOut 0.3s ease-out';
                        setTimeout(() => notification.remove(), 300);
                    }, 3000);
                }

                function initializeCourseForm() {
                    const form = document.getElementById('courseCreationForm');
                    const generateBtn = document.getElementById('generateWaypoints');
                    const waypointCountInput = document.getElementById('waypointCount');
                    const waypointsContainer = document.getElementById('waypointsContainer');

                    if (!form || !generateBtn || !waypointCountInput || !waypointsContainer) {
                        return;
                    }

                    // Check if event listeners are already attached
                    const hasListeners = generateBtn.hasAttribute('data-listeners-attached');

                    if (hasListeners) {
                        return;
                    }

                    // Generate waypoint forms
                    const clickHandler = function(e) {
                        e.preventDefault();
                        
                        const count = parseInt(waypointCountInput.value);
                        waypointsContainer.innerHTML = '';

                        for (let i = 1; i <= count; i++) {
                            const waypointHtml = `
                                <div class="waypoint-item" data-waypoint-id="${i}">
                                    <div class="waypoint-header">
                                        <h4>Balise ${i}</h4>
                                        <div class="waypoint-controls">
                                            <button type="button" class="btn btn-danger btn-small remove-waypoint" data-waypoint="${i}">
                                                üóëÔ∏è Supprimer
                                            </button>
                                        </div>
                                    </div>
                                    <div class="form-group">
                                        <label for="waypoint_${i}_name">Nom de la balise</label>
                                        <input type="text" id="waypoint_${i}_name" name="waypoint_${i}_name" 
                                               placeholder="Ex: Balise ${i}" value="Balise ${i}">
                                    </div>
                                    <p style="color: #666; font-size: 0.9rem; margin: 0;">
                                        üì± Position GPS √† d√©finir sur le terrain via scan QR code
                                    </p>
                                </div>
                            `;
                            waypointsContainer.insertAdjacentHTML('beforeend', waypointHtml);
                        }

                        // Add remove handlers
                        document.querySelectorAll('.remove-waypoint').forEach(btn => {
                            btn.addEventListener('click', function() {
                                const waypointId = this.getAttribute('data-waypoint');
                                const waypointItem = this.closest('.waypoint-item');
                                waypointItem.remove();
                                showNotification(`Balise ${waypointId} supprim√©e`, 'info');
                            });
                        });

                        showNotification(`${count} balises g√©n√©r√©es!`, 'success');
                    };

                    generateBtn.addEventListener('click', clickHandler);

                    // Mark button as having listeners attached
                    generateBtn.setAttribute('data-listeners-attached', 'true');

                // Form submission
                // Function to generate random point within polygon
                function generateRandomPointInPolygon(boundaryPoints) {
                    if (boundaryPoints.length < 3) {
                        return null;
                    }

                    // Find bounding box
                    let minLat = boundaryPoints[0].lat;
                    let maxLat = boundaryPoints[0].lat;
                    let minLng = boundaryPoints[0].lng;
                    let maxLng = boundaryPoints[0].lng;

                    boundaryPoints.forEach(p => {
                        minLat = Math.min(minLat, p.lat);
                        maxLat = Math.max(maxLat, p.lat);
                        minLng = Math.min(minLng, p.lng);
                        maxLng = Math.max(maxLng, p.lng);
                    });

                    // Try to generate a random point inside the polygon (max 100 attempts)
                    for (let attempt = 0; attempt < 100; attempt++) {
                        const lat = minLat + Math.random() * (maxLat - minLat);
                        const lng = minLng + Math.random() * (maxLng - minLng);

                        // Check if point is inside polygon using ray casting algorithm
                        if (isPointInPolygon({lat, lng}, boundaryPoints)) {
                            return {lat, lng};
                        }
                    }

                    // Fallback: return center of bounding box
                    return {
                        lat: (minLat + maxLat) / 2,
                        lng: (minLng + maxLng) / 2
                    };
                }

                // Ray casting algorithm to check if point is inside polygon
                function isPointInPolygon(point, polygon) {
                    let inside = false;
                    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                        const xi = polygon[i].lng, yi = polygon[i].lat;
                        const xj = polygon[j].lng, yj = polygon[j].lat;

                        const intersect = ((yi > point.lat) !== (yj > point.lat))
                            && (point.lng < (xj - xi) * (point.lat - yi) / (yj - yi) + xi);
                        if (intersect) inside = !inside;
                    }
                    return inside;
                }

                form.addEventListener('submit', async function(e) {
                    e.preventDefault();

                    const formData = {
                        name: document.getElementById('courseName').value,
                        description: document.getElementById('courseDescription').value,
                        startPoint: {
                            name: document.getElementById('startPointName').value,
                            description: document.getElementById('startPointDescription').value,
                            lat: null, // Will be filled with random coordinates if boundaries exist
                            lng: null
                        },
                        waypoints: [],
                        boundaryPoints: window.boundaryPoints && window.boundaryPoints.length >= 3 ? [...window.boundaryPoints] : null,
                        status: 'draft',
                        createdAt: new Date().toISOString()
                    };

                    // Generate random coordinates if boundaries are defined
                    if (window.boundaryPoints && window.boundaryPoints.length >= 3) {
                        // Generate random start point
                        const startCoords = generateRandomPointInPolygon(window.boundaryPoints);
                        if (startCoords) {
                            formData.startPoint.lat = startCoords.lat;
                            formData.startPoint.lng = startCoords.lng;
                            console.log('Generated start point coordinates:', startCoords);
                        }
                    }

                    // Collect waypoint data
                    document.querySelectorAll('.waypoint-item').forEach((item, index) => {
                        const id = item.getAttribute('data-waypoint-id');
                        const waypoint = {
                            id: parseInt(id),
                            name: document.getElementById(`waypoint_${id}_name`)?.value || `Balise ${id}`,
                            latitude: null,
                            longitude: null,
                            type: 'control',
                            qr: ''
                        };

                        // Generate random coordinates if boundaries are defined
                        if (window.boundaryPoints && window.boundaryPoints.length >= 3) {
                            const coords = generateRandomPointInPolygon(window.boundaryPoints);
                            if (coords) {
                                waypoint.latitude = coords.lat;
                                waypoint.longitude = coords.lng;
                            }
                        }

                        formData.waypoints.push(waypoint);
                    });

                    console.log('Course data to save:', formData);
                    
                    try {
                        // Save to backend API
                        const response = await fetch('{{ path('api_parcours_save', {'_locale': app.request.locale}) }}', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(formData)
                        });

                        const result = await response.json();

                        if (response.ok && result.success) {
                            showNotification(`Parcours "${formData.name}" cr√©√© avec succ√®s!`, 'success');
                            
                            // Redirect to parcours list after notification
                            setTimeout(() => {
                                window.location.href = '{{ path('app_parcours_list') }}';
                            }, 1500);
                        } else {
                            throw new Error(result.message || 'Erreur lors de la sauvegarde');
                        }
                    } catch (error) {
                        console.error('Error saving course:', error);
                        showNotification('Erreur lors de la cr√©ation du parcours', 'error');
                    }
                });

                // Initialize boundary map buttons
                const addBoundaryBtn = document.getElementById('addBoundaryPoint');
                const clearBoundaryBtn = document.getElementById('clearBoundaryPoints');
                const loadTestBoundaryBtn = document.getElementById('loadTestBoundary');

                if (addBoundaryBtn) {
                    addBoundaryBtn.addEventListener('click', function(e) {
                        e.preventDefault();
                        window.isAddingBoundaryPoint = !window.isAddingBoundaryPoint;
                        if (window.updateAddButtonState) {
                            window.updateAddButtonState();
                        }
                    });
                }

                if (clearBoundaryBtn) {
                    clearBoundaryBtn.addEventListener('click', function(e) {
                        e.preventDefault();
                        if (confirm('Effacer tous les points de limite ?')) {
                            if (window.clearBoundaryPoints) {
                                window.clearBoundaryPoints();
                            }
                        }
                    });
                }

                if (loadTestBoundaryBtn) {
                    loadTestBoundaryBtn.addEventListener('click', function(e) {
                        e.preventDefault();
                        if (window.loadTestBoundaryPoints) {
                            window.loadTestBoundaryPoints();
                        }
                    });
                }
            }

            // Track initialization per Turbo render
            let initialized = false;

            // Clean up on page unload
            document.addEventListener('turbo:before-render', function() {
                initialized = false;
            });

            // Initialize on Turbo load
            document.addEventListener('turbo:load', function() {
                if (!initialized) {
                    initialized = true;
                    initializeCourseForm();
                }
            });

            // Also initialize on DOMContentLoaded (fallback if Turbo doesn't fire)
            document.addEventListener('DOMContentLoaded', function() {
                if (!initialized) {
                    initialized = true;
                    initializeCourseForm();
                }
            });
            
            // Also initialize immediately if DOM is ready (first page load without Turbo)
            if (document.readyState !== 'loading' && !initialized) {
                initialized = true;
                initializeCourseForm();
            }
            })();
        </script>
    {% endblock %}
{% endblock %}
