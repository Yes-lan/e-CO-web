{% extends 'base.html.twig' %}

{% block title %}{{ 'map.title'|trans }} - e-CO{% endblock %}

{% block body %}
<div class="map-view-container">
    <!-- Main Content: Session Selector + Runners Table + Map -->
    <div class="map-content">
        <!-- Left Column: Runners Table -->
        <div class="left-column">
            <!-- Runners Table -->
            <div class="runners-panel">
                <h2>ðŸ‘¥ {{ 'map.runners'|trans }}</h2>
                <div class="runners-table-container">
                    <table class="runners-table">
                        <thead>
                            <tr>
                                <th>{{ 'map.runner_name'|trans }}</th>
                                <th>{{ 'map.beacons_validated'|trans }}</th>
                                <th>{{ 'map.completion_time'|trans }}</th>
                            </tr>
                        </thead>
                        <tbody id="runnersTableBody">
                            <tr>
                                <td colspan="3" class="no-data">{{ 'map.select_session_first'|trans }}</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        
        <!-- Right: Google Map -->
        <div class="map-panel" id="mapPanel">
            <div id="map"></div>
        </div>
    </div>
    
    <!-- Bottom: Beacon Validation Table -->
    <div class="beacon-validation-panel">
        <div id="runnerNameBadge" class="runner-name-badge" style="display: none;"></div>
        <div class="beacon-table-container">
            <div id="beaconValidationContent" class="no-data">
                {{ 'map.select_runner_to_view'|trans }}
            </div>
        </div>
    </div>
</div>

<script>
    let currentSession = null;
    let currentCourse = null;
    let selectedRunnerId = null;
    let map = null;
    let markers = [];
    let labels = [];
    let runnerPaths = [];
    let runnerPathLine = null;
    let scanMarkers = [];

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', function() {
        // Don't call initMap() here - it will be called by Google Maps API callback
        loadSessionData();
    });
    
    // Load session data based on URL parameters
    function loadSessionData() {
        const urlParams = new URLSearchParams(window.location.search);
        const sessionId = urlParams.get('sessionId');
        const courseId = urlParams.get('courseId');
        
        if (courseId) {
            // Came from course/parcours page - load sessions for this course
            loadSessionsForCourse(courseId, sessionId);
        } else if (sessionId) {
            // Direct session link - load all sessions and select the one
            loadSessions(sessionId);
        } else {
            // No parameters - just load all sessions
            loadSessions();
        }
    }



    // Load all sessions grouped by course
    async function loadSessions(autoSelectSessionId = null) {
        try {
            // Auto-load session if specified
            if (autoSelectSessionId) {
                await loadSession(autoSelectSessionId);
            }
        } catch (error) {
            console.error('Error loading sessions:', error);
        }
    }
    
    // Load sessions for a specific course
    async function loadSessionsForCourse(courseId, autoSelectSessionId = null) {
        try {
            const courseRes = await AuthManager.fetch(`/api/parcours/${courseId}`);
            const courseData = await courseRes.json();
            
            const course = courseData.parcours || courseData;
            
            // Load course data immediately
            currentCourse = course;
            updateMap();
            
            // Auto-load session if specified
            if (autoSelectSessionId) {
                await loadSession(autoSelectSessionId);
            }
        } catch (error) {
            console.error('Error loading sessions for course:', error);
        }
    }

    // Load selected session
    async function loadSession(sessionId) {
        if (!sessionId) {
            clearData();
            return;
        }
        
        try {
            const response = await AuthManager.fetch(`/api/sessions/${sessionId}`);
            currentSession = await response.json();
            
            if (currentSession.course) {
                await loadCourseData(currentSession.course.id);
            }
            
            displayRunners();
            updateMap();
        } catch (error) {
            console.error('Error loading session:', error);
        }
    }

    // Load course (parcours) data with beacons
    async function loadCourseData(courseId) {
        try {
            const response = await AuthManager.fetch(`/api/parcours/${courseId}`);
            const data = await response.json();
            currentCourse = data.parcours || data;
        } catch (error) {
            console.error('Error loading course:', error);
        }
    }

    // Display runners in table
    function displayRunners() {
        const tbody = document.getElementById('runnersTableBody');
        
        if (!currentSession || !currentSession.runners || currentSession.runners.length === 0) {
            tbody.innerHTML = '<tr><td colspan="3" class="no-data">{{ 'map.no_runners'|trans }}</td></tr>';
            return;
        }
        
        tbody.innerHTML = currentSession.runners.map(runner => {
            // Calculate beacons validated from beacon_scan logs
            const beaconsValidated = calculateBeaconsValidated(runner);
            const completionTime = calculateCompletionTime(runner);
            
            return `
                <tr onclick="selectRunner(${runner.id})" id="runner-${runner.id}">
                    <td>${runner.name}</td>
                    <td>${beaconsValidated} / ${currentCourse ? currentCourse.waypoints.length : 0}</td>
                    <td>${completionTime}</td>
                </tr>
            `;
        }).join('');
    }
    
    // Calculate number of beacons validated from beacon_scan logs
    function calculateBeaconsValidated(runner) {
        if (!runner.logSessions || !currentCourse || !currentCourse.waypoints) return 0;
        
        // Count unique valid beacon scans (within 20m)
        const beaconScans = runner.logSessions.filter(log => log.type === 'beacon_scan');
        const validBeacons = new Set();
        
        beaconScans.forEach(scan => {
            const beaconId = scan.additionalData;
            const beacon = currentCourse.waypoints.find(b => b.id == beaconId);
            
            if (beacon && scan.latitude && scan.longitude) {
                const distance = calculateDistance(
                    scan.latitude, scan.longitude,
                    beacon.latitude, beacon.longitude
                );
                
                if (distance <= 20) { // Only count valid scans
                    validBeacons.add(beaconId);
                }
            }
        });
        
        return validBeacons.size;
    }

    // Calculate completion time
    function calculateCompletionTime(runner) {
        if (!runner.departure || !runner.arrival) return '-';
        
        const departure = new Date(runner.departure);
        const arrival = new Date(runner.arrival);
        const diff = arrival - departure;
        
        const minutes = Math.floor(diff / 60000);
        const seconds = Math.floor((diff % 60000) / 1000);
        
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    // Select a runner
    function selectRunner(runnerId) {
        selectedRunnerId = runnerId;
        
        // Update row highlighting
        document.querySelectorAll('.runners-table tbody tr').forEach(tr => {
            tr.classList.remove('selected');
        });
        document.getElementById(`runner-${runnerId}`)?.classList.add('selected');
        
        // Update runner name badge
        const runner = currentSession.runners.find(r => r.id === runnerId);
        const badge = document.getElementById('runnerNameBadge');
        if (runner) {
            badge.textContent = runner.name;
            badge.style.display = 'block';
        }
        
        // Load runner's GPS path
        loadRunnerPath(runnerId);
        
        // Display beacon validation table
        displayBeaconValidation(runnerId);
    }

    // Load runner's GPS path
    async function loadRunnerPath(runnerId) {
        try {
            // Clear existing paths and markers
            runnerPaths.forEach(path => path.setMap(null));
            runnerPaths = [];
            scanMarkers.forEach(marker => marker.setMap(null));
            scanMarkers = [];
            
            const runner = currentSession.runners.find(r => r.id === runnerId);
            if (!runner || !runner.logSessions) return;
            
            // Get GPS logs and beacon scans, sorted by time
            const gpsLogs = runner.logSessions
                .filter(log => log.type === 'gps' && log.latitude && log.longitude)
                .sort((a, b) => new Date(a.time) - new Date(b.time));
            
            const beaconScans = runner.logSessions
                .filter(log => log.type === 'beacon_scan' && log.latitude && log.longitude)
                .sort((a, b) => new Date(a.time) - new Date(b.time));
            
            // Merge GPS logs and beacon scans, sorted by time
            const allLogs = [...gpsLogs, ...beaconScans].sort((a, b) => new Date(a.time) - new Date(b.time));
            
            // Draw path segments (don't connect GPS logs if beacon scan is between them)
            if (allLogs.length > 0) {
                let pathSegment = [];
                
                for (let i = 0; i < allLogs.length; i++) {
                    const log = allLogs[i];
                    pathSegment.push({ lat: log.latitude, lng: log.longitude });
                    
                    // If this is a beacon scan or last log, complete the segment
                    if (log.type === 'beacon_scan' || i === allLogs.length - 1) {
                        if (pathSegment.length >= 2) {
                            const polyline = new google.maps.Polyline({
                                path: pathSegment,
                                geodesic: true,
                                strokeColor: '#9C27B0',
                                strokeOpacity: 0.9,
                                strokeWeight: 3,
                                map: map,
                                icons: [{
                                    icon: {
                                        path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
                                        scale: 4,
                                        strokeColor: '#FFFFFF',
                                        strokeWeight: 1.5,
                                        fillColor: '#9C27B0',
                                        fillOpacity: 1
                                    },
                                    offset: '50%'
                                }]
                            });
                            runnerPaths.push(polyline);
                        }
                        // Start new segment with current point
                        pathSegment = log.type === 'beacon_scan' ? [{ lat: log.latitude, lng: log.longitude }] : [];
                    }
                }
            }
            
            // Add small markers for GPS log points
            gpsLogs.forEach(log => {
                const logTime = new Date(log.time);
                const sessionStartTime = currentSession.sessionStart ? new Date(currentSession.sessionStart) : null;
                const elapsedSeconds = sessionStartTime ? Math.floor((logTime - sessionStartTime) / 1000) : null;
                const elapsedFormatted = elapsedSeconds !== null ? formatElapsedTime(elapsedSeconds) : '-';
                
                const gpsMarker = new google.maps.Marker({
                    position: { lat: log.latitude, lng: log.longitude },
                    map: map,
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 3,
                        fillColor: '#9C27B0',
                        fillOpacity: 1,
                        strokeColor: '#FFFFFF',
                        strokeWeight: 1
                    },
                    title: `GPS: ${logTime.toLocaleTimeString('fr-FR')}`,
                    zIndex: 500
                });
                
                const gpsInfoWindow = new google.maps.InfoWindow({
                    content: `
                        <div style="padding: 4px; font-size: 12px; min-width: 120px;">
                            ${trans('map.time')}: ${logTime.toLocaleTimeString('fr-FR')}<br>
                            ${trans('map.elapsed')}: ${elapsedFormatted}
                        </div>
                    `
                });
                
                gpsMarker.addListener('click', () => {
                    gpsInfoWindow.open(map, gpsMarker);
                });
                
                scanMarkers.push(gpsMarker);
            });
            
            // Display beacon scan markers
            beaconScans.forEach(scan => {
                const beaconId = parseInt(scan.additionalData);
                const beacon = currentCourse.waypoints.find(b => b.id === beaconId);
                
                if (beacon) {
                    // Calculate distance between scan location and actual beacon location
                    const distance = calculateDistance(
                        scan.latitude, scan.longitude,
                        beacon.latitude, beacon.longitude
                    );
                    
                    // Determine if scan is valid (within 20 meters)
                    const isValid = distance <= 20;
                    const markerColor = isValid ? '#4CAF50' : '#F44336'; // Green or Red
                    
                    const scanTime = new Date(scan.time);
                    const sessionStartTime = currentSession.sessionStart ? new Date(currentSession.sessionStart) : null;
                    const elapsedSeconds = sessionStartTime ? Math.floor((scanTime - sessionStartTime) / 1000) : null;
                    const elapsedFormatted = elapsedSeconds !== null ? formatElapsedTime(elapsedSeconds) : '-';
                    
                    // Create custom marker for scan location
                    const scanMarker = new google.maps.Marker({
                        position: { lat: scan.latitude, lng: scan.longitude },
                        map: map,
                        icon: {
                            path: google.maps.SymbolPath.CIRCLE,
                            scale: 8,
                            fillColor: markerColor,
                            fillOpacity: 0.9,
                            strokeColor: '#FFFFFF',
                            strokeWeight: 2
                        },
                        title: `Scan ${beacon.name} - ${isValid ? 'Valid' : 'Invalid'} (${distance.toFixed(1)}m)`,
                        zIndex: 1000
                    });
                    
                    // Add info window
                    const infoWindow = new google.maps.InfoWindow({
                        content: `
                            <div style="padding: 4px; font-size: 12px; min-width: 140px;">
                                <strong>${beacon.name}</strong><br>
                                ${trans('map.distance')}: ${distance.toFixed(1)}m<br>
                                ${trans('map.status')}: <span style="color: ${markerColor}; font-weight: bold;">
                                    ${isValid ? 'âœ“ ' + trans('map.valid') : 'âœ— ' + trans('map.invalid')}
                                </span><br>
                                ${trans('map.time')}: ${scanTime.toLocaleTimeString('fr-FR')}<br>
                                ${trans('map.elapsed')}: ${elapsedFormatted}
                            </div>
                        `
                    });
                    
                    scanMarker.addListener('click', () => {
                        infoWindow.open(map, scanMarker);
                    });
                    
                    scanMarkers.push(scanMarker);
                }
            });
            
            // Adjust map bounds to fit all runner's points
            if (allLogs.length > 0) {
                const bounds = new google.maps.LatLngBounds();
                
                // Include all GPS logs and beacon scans
                allLogs.forEach(log => {
                    bounds.extend({ lat: log.latitude, lng: log.longitude });
                });
                
                // Also include course beacons for context
                if (currentCourse && currentCourse.waypoints) {
                    currentCourse.waypoints.forEach(beacon => {
                        if (beacon.lat && beacon.lng) {
                            bounds.extend({ lat: beacon.lat, lng: beacon.lng });
                        }
                    });
                }
                
                map.fitBounds(bounds);
                
                // Add padding to bounds
                const padding = { top: 50, right: 50, bottom: 50, left: 50 };
                map.fitBounds(bounds, padding);
            }
            
        } catch (error) {
            console.error('Error loading runner path:', error);
        }
    }
    
    // Calculate distance between two GPS coordinates (Haversine formula)
    function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371e3; // Earth's radius in meters
        const Ï†1 = lat1 * Math.PI / 180;
        const Ï†2 = lat2 * Math.PI / 180;
        const Î”Ï† = (lat2 - lat1) * Math.PI / 180;
        const Î”Î» = (lon2 - lon1) * Math.PI / 180;
        
        const a = Math.sin(Î”Ï†/2) * Math.sin(Î”Ï†/2) +
                  Math.cos(Ï†1) * Math.cos(Ï†2) *
                  Math.sin(Î”Î»/2) * Math.sin(Î”Î»/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        
        return R * c; // Distance in meters
    }
    
    // Format elapsed time in seconds to MM:SS format
    function formatElapsedTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    // Display beacon validation table
    function displayBeaconValidation(runnerId) {
        if (!currentCourse || !currentCourse.waypoints) {
            document.getElementById('beaconValidationContent').innerHTML = '<div class="no-data">{{ 'map.no_course_data'|trans }}</div>';
            return;
        }
        
        const runner = currentSession.runners.find(r => r.id === runnerId);
        if (!runner) return;
        
        // Get beacon scans for this runner
        const beaconScans = runner.logSessions ? runner.logSessions.filter(log => log.type === 'beacon_scan') : [];
        
        // Create a map of beacon ID to scan data with validation
        const scanMap = {};
        beaconScans.forEach(scan => {
            const beaconId = scan.additionalData;
            const beacon = currentCourse.waypoints.find(b => b.id == beaconId);
            
            if (beacon && scan.latitude && scan.longitude) {
                const distance = calculateDistance(
                    scan.latitude, scan.longitude,
                    beacon.latitude, beacon.longitude
                );
                const isValid = distance <= 20; // 20 meters threshold
                
                if (!scanMap[beaconId]) {
                    scanMap[beaconId] = {
                        scan: scan,
                        distance: distance,
                        isValid: isValid
                    };
                }
            }
        });
        
        const tableHTML = `
            <table class="beacon-validation-table">
                <thead>
                    <tr>
                        <th>{{ 'map.status'|trans }}</th>
                        ${currentCourse.waypoints.map((beacon, idx) => `<th>${beacon.name || 'Balise ' + (idx + 1)}</th>`).join('')}
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>{{ 'map.validation'|trans }}</strong></td>
                        ${currentCourse.waypoints.map(beacon => {
                            const scanData = scanMap[beacon.id];
                            if (scanData && scanData.isValid) {
                                return '<td class="status-validated">âœ“</td>';
                            } else if (scanData && !scanData.isValid) {
                                return '<td class="status-invalid">âœ—</td>';
                            }
                            return '<td class="status-pending">-</td>';
                        }).join('')}
                    </tr>
                    <tr>
                        <td><strong>{{ 'map.scan_time'|trans }}</strong></td>
                        ${currentCourse.waypoints.map(beacon => {
                            const scanData = scanMap[beacon.id];
                            if (scanData && scanData.scan.time) {
                                const time = new Date(scanData.scan.time);
                                return `<td>${time.toLocaleTimeString('fr-FR', {hour: '2-digit', minute: '2-digit', second: '2-digit'})}</td>`;
                            }
                            return '<td>-</td>';
                        }).join('')}
                    </tr>
                    <tr>
                        <td><strong>{{ 'map.distance'|trans }}</strong></td>
                        ${currentCourse.waypoints.map(beacon => {
                            const scanData = scanMap[beacon.id];
                            if (scanData) {
                                const distClass = scanData.isValid ? 'status-validated' : 'status-invalid';
                                return `<td class="${distClass}">${scanData.distance.toFixed(1)}m</td>`;
                            }
                            return '<td>-</td>';
                        }).join('')}
                    </tr>
                </tbody>
            </table>
        `;
        
        document.getElementById('beaconValidationContent').innerHTML = tableHTML;
    }

    // Update map with course beacons
    function updateMap() {
        if (!map || !currentCourse || !currentCourse.waypoints) return;
        
        // Clear existing markers and labels
        markers.forEach(m => m.setMap(null));
        labels.forEach(l => l.setMap(null));
        markers = [];
        labels = [];
        
        const bounds = new google.maps.LatLngBounds();
        
        // Add beacon markers
        currentCourse.waypoints.forEach((beacon, idx) => {
            if (!beacon.lat || !beacon.lng) return;
            
            const lat = parseFloat(beacon.lat);
            const lng = parseFloat(beacon.lng);
            
            // Create marker
            const marker = new google.maps.Marker({
                position: { lat, lng },
                map: map,
                title: beacon.name || `Balise ${idx + 1}`,
                icon: {
                    path: 'M 0,0 C -2,-20 -10,-22 -10,-30 A 10,10 0 1,1 10,-30 C 10,-22 2,-20 0,0 z',
                    fillColor: '#2196F3',
                    fillOpacity: 1,
                    strokeColor: '#ffffff',
                    strokeWeight: 2,
                    scale: 1,
                    anchor: new google.maps.Point(0, 0)
                }
            });
            
            // Create label with outline
            const labelDiv = document.createElement('div');
            labelDiv.style.position = 'absolute';
            labelDiv.style.fontSize = '14px';
            labelDiv.style.fontWeight = 'bold';
            labelDiv.style.color = '#2196F3';
            labelDiv.style.textShadow = `-2px -2px 0 #fff, 2px -2px 0 #fff, -2px 2px 0 #fff, 2px 2px 0 #fff, -2px 0 0 #fff, 2px 0 0 #fff, 0 -2px 0 #fff, 0 2px 0 #fff`;
            labelDiv.style.whiteSpace = 'nowrap';
            labelDiv.style.transform = 'translate(-50%, -45px)';
            labelDiv.style.pointerEvents = 'none';
            labelDiv.style.userSelect = 'none';
            labelDiv.style.zIndex = '1000';
            labelDiv.textContent = beacon.name || `Balise ${idx + 1}`;
            
            class LabelOverlay extends google.maps.OverlayView {
                constructor(position, labelElement) {
                    super();
                    this.position = position;
                    this.labelElement = labelElement;
                }
                
                onAdd() {
                    this.getPanes().overlayMouseTarget.appendChild(this.labelElement);
                }
                
                draw() {
                    const projection = this.getProjection();
                    const point = projection.fromLatLngToDivPixel(this.position);
                    if (point) {
                        this.labelElement.style.left = point.x + 'px';
                        this.labelElement.style.top = point.y + 'px';
                    }
                }
                
                onRemove() {
                    if (this.labelElement.parentElement) {
                        this.labelElement.parentElement.removeChild(this.labelElement);
                    }
                }
            }
            
            const labelOverlay = new LabelOverlay(new google.maps.LatLng(lat, lng), labelDiv);
            labelOverlay.setMap(map);
            
            markers.push(marker);
            labels.push(labelOverlay);
            bounds.extend({ lat, lng });
        });
        
        // Fit map to show all markers
        if (!bounds.isEmpty()) {
            map.fitBounds(bounds);
        }
    }

    // Initialize Google Maps (called by API callback)
    function initMap() {
        map = new google.maps.Map(document.getElementById('map'), {
            center: { lat: 43.3, lng: -1.5 },
            zoom: 13,
            mapTypeId: 'roadmap',
            streetViewControl: false,
            rotateControl: false,
            tilt: 0,
            styles: [
                {
                    featureType: 'poi',
                    elementType: 'labels',
                    stylers: [{ visibility: 'off' }]
                },
                {
                    featureType: 'transit',
                    elementType: 'labels',
                    stylers: [{ visibility: 'off' }]
                }
            ]
        });
        
        // Load session data after map is initialized
        loadSessionData();
    }

    // Clear all data
    function clearData() {
        currentSession = null;
        currentCourse = null;
        selectedRunnerId = null;
        
        document.getElementById('runnersTableBody').innerHTML = '<tr><td colspan="3" class="no-data">{{ 'map.select_session_first'|trans }}</td></tr>';
        document.getElementById('beaconValidationContent').innerHTML = '<div class="no-data">{{ 'map.select_runner_to_view'|trans }}</div>';
        document.getElementById('runnerNameBadge').style.display = 'none';
        
        markers.forEach(m => m.setMap(null));
        labels.forEach(l => l.setMap(null));
        runnerPaths.forEach(p => p.setMap(null));
        markers = [];
        labels = [];
        runnerPaths = [];
    }

    // Load Google Maps API
    window.initMap = initMap;
</script>

<script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBi8sXKGGafzB837kvxraWuqohlZ-JJRu8&libraries=geometry,places&callback=initMap" async defer></script>

{% endblock %}
